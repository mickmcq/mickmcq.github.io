---
title: UCD and Agile
author: Mick McQuaid
date: 2022-07-10
bibliography: master.bib
format:
  revealjs:
    theme: moon
    css: style.css
    transition: slide
    background-transition: fade
    preview-links: auto
    controls: true
    controls-layout: bottom-right
---

# Intro

This material comes from a NordiCHI conference workshop on UCD and Agile, documented in @Cockton2016.

## What is UCD (User Centered Design)?
- When did it start?
- What was the software environment in which it began?
- How has it developed?
- How can it be integrated with Agile development?

## Some facts about UCD
- It started in the eighties, as a result of plummeting hardware costs, leading to the rise of casual users
- Software engineering at the time was concerned with the software artifact, not users, and waterfall processes dominated the landscape
- Its initial focus was usability, later defined by ISO 9241 as “the extent to which a product can be used by specified users to achieve specified goals with effectiveness, efficiency and satisfaction in a specified context of use”
- The above definition grew and developed over time

::: {.notes}
In the early days, efficiency dominated the discussion of users as computers were still a scarce resource. Efficiency receded in importance over time while effectiveness and later satisfaction came to the foreground. Satisfaction originally had to be linked to productivity to be justified, rather than being an end itself. Later that changed and context became more important.
:::

## Still later, UCD embraced UX
- UI = user interface, focused on the human-computer interaction
- UX = user experience, more broadly focused on the user's world

::: {.notes}
Eventually, UCD took on the form we see today, a combination of UI and UX, which takes into account the context of use and overarching goals that may be served by the software.

But first, we have to consider the road UCD took to get there.
:::

## Early Challenges for UCD
- The phased approach of waterfall methods meant that UCD had to find a place in each phase (not easy)
- UCD fit better into an iterative approach than a phased approach
- UCD activities like Contextual Inquiry fit into the problem analysis phase
- UCD activities like user testing fit the verification phase

::: {.notes}
Other phases were harder and the whole arduous process was made more difficult by one of the hallmarks of waterfall: that there's no going back from one phase to a previous phase. If you find out you've taken a wrong turn, that's tough. This rigidity about phases allows for easier budgeting and accounting and makes waterfall appealing for expensive projects. Line for line of code, waterfall is always cheaper than iterative, although it is more likely to fail because of its rigidity.
:::

## Waterfall phases
- problem analysis
- requirements specification
- design
- implementation
- verification
- operation

::: {.notes}
On paper, this phased approach looks like a good idea. It breaks work up into manageable chunks. The fatal flaw is that everyone signs an agreement at the end of each phase, declaring that they are satisfied that that phase is complete. Hence, waterfall is commonly used when the administrative distance between parties is great. That distance can occur between departments, agencies, or companies. The farther up the food chain you have to travel to resolve disputes, the greater the administrative distance.
:::

## Iterative software development

```{mermaid}
flowchart LR
    A-->B
    B-->C
    C-->A
```

## Iterative software development
- It is less risky, but more expensive, to iterate
- The iterative process is design, build, test, over and over
- Why is it less risky?
- Why is it more expensive?

::: {.notes}
It's less risky because client and provider have more chances to be on the same page. It's more expensive because there's a lot of intermediate work that just gets thrown away: intermediate prototypes and demos that help get everyone on the same page but can't be used in the actual software product.
:::

# Enter Agile

## What is Agile?
- First and foremost, it is a manifesto, posted in 2001, featuring twelve principles
- Everybody and his brother loved the manifesto
- Pretty soon, everybody and his brother started saying they were Agile
- Agile started to lose meaning
- Let's try to capture some of that meaning

::: {.notes}
Let's review the Agile Manifesto to see why it was so attractive to so many people, then talk a bit about measuring Agile development.
:::

## Agile software development principles (1)
 1. Customer satisfaction by early and continuous delivery of valuable software.
 2. Welcome changing requirements, even in late development.
 3. Deliver working software frequently (weeks rather than months)
 4. Close, daily cooperation between business people and developers

## Agile software development principles (2)
 5. Projects are built around motivated individuals, who should be trusted
 6. Face-to-face conversation is the best form of communication (co-location)
 7. Working software is the primary measure of progress
 8. Sustainable development, able to maintain a constant pace

::: {.notes}
The items on this list are intuitively appealing to a lot of people despite little empirical evidence for their value. For example, managers often micromanage because they don't understand what developers are doing. They require time-consuming reports of little real value in lieu of understanding. Principle 5 seems like a sensible reaction to this phenomenon.
:::

## Agile software development principles (3)
 9. Continuous attention to technical excellence and good design
10. Simplicity—the art of maximizing the amount of work not done—is essential
11. Best architectures, requirements, and designs emerge from self-organizing teams
12. Regularly, the team reflects on how to become more effective, and adjusts accordingly

::: {.notes}
Again, these principles react to overly rigid top-down management of the development process by managers unfamiliar with that process. It sounds good, albeit very expensive. It sounds like it reduces risk.
:::

## What agile looks like
Collaboration between

- Cross-functional teams
- Self-organizing teams
- Users / Stakeholders on the team

Focus on

- flexibility
- early delivery
- continuous improvement

## Further reading on Agile
Vastly many agile processes and practices are documented on Wikipedia's *Agile Software Development* page, including the following diagram of one attempt to merge the best parts of agile and waterfall.

---

![Unified Process Model](fiUnifiedProcessModel.png)

::: {.notes}
Diagram found at [https://commons.wikimedia.org/wiki/File:Unified_Process_Model_for_Iterative_Development.svg](https://commons.wikimedia.org/wiki/File:Unified_Process_Model_for_Iterative_Development.svg)

The key issues in my mind are whether the people in charge can say "It's too early to test" or "It's too late to change". If they can say those things, the process is too waterfally. Can a process be too agiley? The Wikipedia article gives a long list of Agile pitfalls.
:::

# Major Concerns

- Cultures
- Teams
- Tasks
- Research approaches

## References

::: {#refs}
:::

---

::: {.r-fit-text}
END
:::

# Colophon

This slideshow was produced using `quarto`

Fonts are *League Gothic* and *Lato*

